# configuration for the ansible provisioner.


# Ansible CFG contents which will be written to a file as toml.
# This might not be safe, we haven't figured that out yet.
# ansiblecfg:
#   path: "{{variables:files_path}}/{{variables:files_prefix}}.ansible.cfg"
#   contents:
#     ssh_connection:
#       pipelining: true
#       ssh_args: -o ControlMaster=auto -o ControlPersist=30m -o ConnectionAttempts=100 -o UserKnownHostsFile=/dev/null
#     defaults:
#       host_key_checking: false
#       fact_caching: jsonfile
#       fact_caching_connection: ./.fact_cache
#       fact_caching_timeout: 300
#       callback_whitelist: profile_tasks
#       deprecation_warnings: false
#       inventory_ignore_extension: ~, .orig, .bak, .ini, .cfg, .retry, .pyc, .pyo, .creds

# Anvislbe inventory which will be written to file as flat text.
inventory:
  path: "{{variables:files_path}}/{{variables:files_prefix}}.inventory"
  # here we expect that another process has created an output plugin with the required contents
  # typical for ansible, a terraform plugin has created the output based on created infra.
  contents: "{{output::ansible_inventory?special::None}}"

# List of playbooks which will be run in sequence on apply
playbooks:
- name: Host debug
  hosts: all
  gather_facts: yes
  tasks:
  - action:
      module: debug

# We could load directly from a playbook yaml file:
#
# All playbooks:
# playbooks: "{{file::path/to/playbooks.yml}}"
#
# single playbook:
# playbooks:
# - "{{file::path/to/playbook.yml}}"
# - "{{file::path/to/playbook.yml}}"
# - "{{file::path/to/playbook.yml}}"
